"""
Asynchronous Web Server Module for ESP32 IoT Control System
=========================================================

Provides a lightweight, asynchronous HTTP server for ESP32 with REST API
endpoints for device control, status monitoring, and system management.
Built using uasyncio for efficient concurrent request handling.

Author: Erfan Mohamadnia
License: MIT
Version: 1.0.0

Features:
- Asynchronous request handling with uasyncio
- RESTful API endpoints for device control
- JSON response format for easy integration
- Automatic device timeout management
- Concurrent connection support
- Error handling and status reporting

API Endpoints:
- /relay/<channel>/<action>     - Control relay channels (on/off)
- /servo/<angle>               - Set servo position (0-180Â°)
- /status                      - Get system status and time

Hardware Integration:
- RelayController: Multi-channel relay management
- ServoController: PCA9685-based servo control
- Timer-based automatic device shutdown

Dependencies:
- uasyncio: Asynchronous I/O operations
- ujson: JSON encoding/decoding
- time: System time functions
- machine: Hardware timer support

Generated by Copilot
"""

import uasyncio as asyncio
import ujson as json
import time
from machine import Timer


class WebServer:
    """
    Asynchronous HTTP server for ESP32 IoT device control.
    
    This class implements a lightweight web server that provides REST API
    endpoints for controlling connected devices (relays, servos) and
    monitoring system status. Uses asynchronous request handling for
    better performance and concurrent connection support.
    
    Attributes:
        relay_controller: Interface to relay control hardware
        servo_controller: Interface to servo motor control
        server: AsyncIO server object for handling connections
        auto_off_timers: Dictionary of active automatic shutdown timers
    """
    
    def __init__(self, relay_controller, servo_controller):
        """
        Initialize web server with hardware controllers.
        
        Args:
            relay_controller: RelayController instance for device switching
            servo_controller: ServoController instance for servo positioning
        """
        self.relay_controller = relay_controller
        self.servo_controller = servo_controller
        self.server = None
        self.auto_off_timers = {}  # Store active auto-off tasks
        
    async def handle_request(self, reader, writer):
        """
        Asynchronously process incoming HTTP requests.
        
        Parses HTTP request headers, routes to appropriate handlers,
        and sends JSON responses. Handles errors gracefully and
        ensures proper connection cleanup.
        
        Args:
            reader: AsyncIO stream reader for request data
            writer: AsyncIO stream writer for response data
        """
        try:
            # Read and parse HTTP request line
            request_line = await reader.readline()
            request_line = request_line.decode('utf-8').strip()
            
            # Extract HTTP method, path, and version
            method, path, _ = request_line.split(' ')
            
            # Read and discard HTTP headers (simple implementation)
            while True:
                line = await reader.readline()
                if line == b'\r\n':
                    break
            
            # Parse URL parameters if present
            if '?' in path:
                path, params = path.split('?', 1)
                params = self._parse_params(params)
            else:
                params = {}
            
            # Route request to appropriate handler
            response = await self._route_request(method, path, params)
            
            # Send HTTP response
            writer.write(response.encode('utf-8'))
            await writer.drain()
            await writer.wait_closed()
            
        except Exception as e:
            # Handle errors with 500 Internal Server Error response
            error_response = f"HTTP/1.1 500 Internal Server Error\r\nContent-Type: text/plain\r\n\r\nError: {str(e)}"
            writer.write(error_response.encode('utf-8'))
            await writer.drain()
            await writer.wait_closed()
    
    def _parse_params(self, param_string):
        """
        Parse URL query parameters from string format.
        
        Converts URL parameter string (key1=value1&key2=value2) into
        a dictionary for easy access in request handlers.
        
        Args:
            param_string (str): URL parameter string
            
        Returns:
            dict: Dictionary of parameter key-value pairs
        """
        params = {}
        for param in param_string.split('&'):
            if '=' in param:
                key, value = param.split('=', 1)
                params[key] = value
        return params
    
    async def _route_request(self, method, path, params):
        """
        Route HTTP requests to appropriate handler functions.
        
        Analyzes the request path and directs it to the correct handler
        function based on the API endpoint structure.
        
        Args:
            method (str): HTTP method (GET, POST, etc.)
            path (str): Request path/endpoint
            params (dict): URL query parameters
            
        Returns:
            str: Complete HTTP response string
        """
        if path.startswith('/relay/'):
            return await self._handle_relay_request(path, params)
        elif path.startswith('/servo/'):
            return await self._handle_servo_request(path, params)
        elif path == '/status':
            return await self._handle_status_request()
        else:
            return "HTTP/1.1 404 Not Found\r\nContent-Type: text/plain\r\n\r\nEndpoint not found"
    
    async def _handle_relay_request(self, path, params):
        """
        Process relay control API requests.
        
        Handles HTTP requests for turning relay channels on/off with optional
        duration parameter for automatic shutdown. Supports individual channel
        control and validates input parameters.
        
        Args:
            path (str): Request path containing channel and action
            params (dict): URL parameters including optional duration
            
        Returns:
            str: Complete HTTP response with JSON status
        """
        try:
            parts = path.split('/')
            if len(parts) >= 4:
                channel = int(parts[2])
                action = parts[3]
                
                if action == 'on':
                    self.relay_controller.on(channel)
                    
                    # Handle optional duration parameter for auto-off
                    if 'duration' in params:
                        duration = int(params['duration'])
                        await self.auto_off_relay(channel, duration)
                    
                    response_data = {"status": "success", "message": f"Relay {channel} turned ON"}
                    
                elif action == 'off':
                    self.relay_controller.off(channel)
                    
                    # Cancel any existing auto-off timer for this channel
                    if channel in self.auto_off_timers:
                        self.auto_off_timers[channel].cancel()
                        del self.auto_off_timers[channel]
                    
                    response_data = {"status": "success", "message": f"Relay {channel} turned OFF"}
                else:
                    response_data = {"status": "error", "message": "Invalid action"}
            else:
                response_data = {"status": "error", "message": "Invalid relay request"}
            
            json_response = json.dumps(response_data)
            return f"HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{json_response}"
            
        except Exception as e:
            error_data = {"status": "error", "message": str(e)}
            json_response = json.dumps(error_data)
            return f"HTTP/1.1 500 Internal Server Error\r\nContent-Type: application/json\r\n\r\n{json_response}"
    
    async def _handle_servo_request(self, path, params):
        """
        Process servo positioning API requests.
        
        Handles HTTP requests for setting servo motor angle position.
        Validates angle range (0-180 degrees) and provides error feedback
        for invalid inputs.
        
        Args:
            path (str): Request path containing target angle
            params (dict): URL parameters (unused for servo requests)
            
        Returns:
            str: Complete HTTP response with JSON status
        """
        try:
            parts = path.split('/')
            if len(parts) >= 3:
                angle = int(parts[2])
                
                if 0 <= angle <= 180:
                    self.servo_controller.set_angle(angle)
                    response_data = {"status": "success", "message": f"Servo set to {angle} degrees"}
                else:
                    response_data = {"status": "error", "message": "Invalid angle (0-180)"}
            else:
                response_data = {"status": "error", "message": "Invalid servo request"}
            
            json_response = json.dumps(response_data)
            return f"HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{json_response}"
            
        except Exception as e:
            error_data = {"status": "error", "message": str(e)}
            json_response = json.dumps(error_data)
            return f"HTTP/1.1 500 Internal Server Error\r\nContent-Type: application/json\r\n\r\n{json_response}"
    
    async def _handle_status_request(self):
        """
        Process system status API requests.
        
        Returns current system status including time information and
        operational status of hardware components. Provides a health
        check endpoint for monitoring system state.
        
        Returns:
            str: Complete HTTP response with JSON system status
        """
        try:
            current_time = time.localtime()
            status_data = {
                "status": "success",
                "time": {
                    "year": current_time[0],
                    "month": current_time[1],
                    "day": current_time[2],
                    "hour": current_time[3],
                    "minute": current_time[4],
                    "second": current_time[5]
                },
                "relays": "operational",
                "servo": "operational"
            }
            
            json_response = json.dumps(status_data)
            return f"HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{json_response}"
            
        except Exception as e:
            error_data = {"status": "error", "message": str(e)}
            json_response = json.dumps(error_data)
            return f"HTTP/1.1 500 Internal Server Error\r\nContent-Type: application/json\r\n\r\n{json_response}"
    
    async def auto_off_relay(self, channel, duration):
        """
        Create asynchronous task for automatic relay shutdown.
        
        Creates a background task that will automatically turn off the
        specified relay channel after the given duration. Cancels any
        existing auto-off task for the same channel.
        
        Args:
            channel (int): Relay channel number to control
            duration (int): Delay before automatic shutdown (seconds)
        """
        async def auto_off_task():
            """Internal task function for delayed relay shutdown."""
            await asyncio.sleep(duration)
            self.relay_controller.off(channel)
            if channel in self.auto_off_timers:
                del self.auto_off_timers[channel]
        
        # Cancel existing auto-off timer for this channel
        if channel in self.auto_off_timers:
            self.auto_off_timers[channel].cancel()
        
        # Create and store new auto-off task
        self.auto_off_timers[channel] = asyncio.create_task(auto_off_task())
    
    async def start(self, host='0.0.0.0', port=80):
        """
        Start the asynchronous web server.
        
        Initializes the asyncio server on the specified host and port,
        and begins listening for incoming HTTP requests. The server
        runs indefinitely until manually stopped or an error occurs.
        
        Args:
            host (str): IP address to bind to (default: '0.0.0.0' for all interfaces)
            port (int): TCP port to listen on (default: 80 for HTTP)
        """
        print(f"ðŸŒ Starting web server on {host}:{port}")
        print(f"ðŸŒ Ø´Ø±ÙˆØ¹ ÙˆØ¨â€ŒØ³Ø±ÙˆØ± Ø¯Ø± {host}:{port}")
        
        self.server = await asyncio.start_server(self.handle_request, host, port)
        print(f"âœ… Web server started successfully on http://{host}:{port}")
        print(f"âœ… ÙˆØ¨â€ŒØ³Ø±ÙˆØ± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø´Ø±ÙˆØ¹ Ø´Ø¯ Ø¯Ø± http://{host}:{port}")
        
        # Keep server running until closed
        async with self.server:
            await self.server.wait_closed()
    
    def stop(self):
        """
        Stop the web server gracefully.
        
        Closes the server socket and stops accepting new connections.
        Existing connections are allowed to complete their current requests.
        """
        if self.server:
            self.server.close()
            print("ðŸ›‘ Web server stopped")
            print("ðŸ›‘ ÙˆØ¨â€ŒØ³Ø±ÙˆØ± Ù…ØªÙˆÙ‚Ù Ø´Ø¯")
